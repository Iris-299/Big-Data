# 算法的时间复杂度分析
* **事后分析估算方法**：计时器计时
  > 缺陷：必须依据算法实现编制好的测试程序，要花费大量时间和精力，如果不行要全部重来，并且不同的测试环境（硬件）的差别导致测试的结果差异很大。

```python
  long start = System.currentTimeMills();
  ...
  long end = System.currentTimeMills();
  System.out.println(end-start);
```
 
* **事前分析估算方法**：<br> 

  程序在计算机上运行所消耗的时间取决于下列因素：
    1. **算法采用的策略和方案**；
    2. 编译产生的代码质量；
    3. **问题的输入规模（输入量的多少）**；
    4. 机器执行指令的速度；
    
  <br> 例：计算1到100的和
```python
  #第一种方法（算法一）
  public static void main(String[] args){
      int sum = 0;//执行1次
      int n = 100;//执行1次
      for (int i = 1; i <= n; i++){//执行了n+1次
          sum += 1；//执行了n次
      }
      System.out.println("sum = " + sum);
  }
```
```python
  #第二种方法（算法二）
  public static void main(String[] args){
      int sum = 0;//执行1次
      int n = 100;//执行1次
      sum = (n+1)*n/2;//执行1次
      System.out.println("sum = " + sum);
  }
```
&emsp;&emsp;当输入规模为n时，把循环体看成整体，忽略结束条件的判断，两个算法的运行时间的差距就是n和1的差距。
  
<br> &emsp;&emsp;要精确研究循环条件执行多少次很麻烦并且真正计算的代码是内循环的循环体，所以在研究算法效率时，我们只考虑核心代码的执行次数，这样可以简化分析。
```python
  #计算100个1+100个2+100个3+……100个100的结果：（算法三）

  public static void main(String[] args){
      int sum = 0;
      int n = 100;
      for (int i = 1; i <= n; i++){
          for (int j = 1; j <= n; j++){
              sum += 1;
          }
      }
      System.out.println("sum = " + sum);
  }
```
&emsp;&emsp;**我们分析一个算法的时间最重要的就是把核心操作的次数和输入规模关联起来。**
## 01 函数渐进增长
> 给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n>N，f(n)总是比g(n)大,那么我们说f(n)的增长渐进快于g(n)。

* **随着输入规模的增大，算法的常数操作可以忽略不计。**
* **随着输入规模的增大，与最高次项项乘的常数可以忽略。**
* **最高次项的指数大的，随着n的增长，结果也会变得增长特别快。**
* **算法函数中n最高次幂越小，算法效率越高。**

## 02 算法时间复杂度
### 大O记法
> 在进行算法分析时，语句总的执行次数T(n)是关于规模n的函数。算法的时间复杂度，就是算法的时间量度，记作：**T(n)=O(f(n))**。用大写O()来体现算法时间复杂度的记法，我们称之为大O记法。

* 推导大O阶的表示法的规则：
  1. 用常数1取代运行时间中的所有假发常数；
  2. 在修改后的运行次数中，只保留高阶项；
  3. 如果最高阶项存在，且常数因子不为1，则去除这个项项乘的常数；

  所以，上述三个算法的大O记法分别为：
    <br> &emsp;&emsp;算法一：O(n)
    <br> &emsp;&emsp;算法二：O(1)
    <br> &emsp;&emsp;算法三：O(n^2)
    
* 常见的大O阶
  - 线性阶
    <br> 一般含有非嵌套循环涉及线性阶，线性阶就是随着输入规模的扩大，对应计算次数呈直线增长，例如：算法一。
  
  - 平方阶
    <br> 一般嵌套循环属于这种时间复杂度。如算法三。
    
  - 立方阶
    <br> 一般三层嵌套属于这种时间复杂度。
    
  - 对数阶
    <br> 由于每次i*2之后，就距离n更近一步，假设有x个2相乘后大于n，则会退出循环。于是2^x=n，得到x=log2(n)，因此时间复杂度为O(logn);
    <br> 对于对数阶，由于随着输入规模n的增大，不管底数多少，趋势相同，因此可忽略底数。
  ```python
    int i = 1, n= 100;
    while(i < n){
      i = i*2;
    }
  ```

  - 常数阶
    <br> 一般不涉及循环操作的都是常数阶，因为它不会随着n的增长而增长增加操作次数。如算法二。
    
  **总结**
  |描述|增长的数量级|说明|举例|
  |:-|:-|:-|:-|
  |常数级别|1|普通语句|将两个数相加|
  |对数级别|logN|二分策略|二分查找|
  |线性级别|N|循环|找出最大元素|
  |线型对数级别|NlogN|分治思想|归并排序|
  |平方级别|N^2|双层循环|检查所有元素对|
  |立方级别|N^3|三层循环|检查所有三元组|
  |指数级别|2^N|穷举查找|检查所有子集|
  
  他们的复杂程度从低到高依次为：
    <br> O(1)<O(logn)<O(n^2)<O(n^3)
  <br> 如果算法的时间复杂度为平方阶、立方阶或者更复杂的，我们认为这种算法是不可取的，需要优化。
  
* 函数调用的时间复杂度分析
  - 案例
  ```python
    public static void main(String[] args){
        int n = 100;
        show(n);
        for (int i = 1; i <= n; i++){
            show(i);
        }
        for (int i = 1; i <= n; i++){
            for (int j = 1; j <= n; j++){
                System.out.println(i);
            }
        }
    }
    
    private static void show(int i){
        for (int i = 1; i <= n; i++){
            System.out.println(i);
        }
    }
  ```
    在show方法中，有一个for循环，所以show方法的时间复杂度为O(n)，在main方法中，show(n)这行代码内部执行次数为n，第一个for循环内调用了show方法，所以其执行次数为n^2，第二个嵌套for循环内只执行了一行代码，所以其执行次数为n^2，那么main方法总执行次数为n+n^2+n^2。由根据大O推导规则，所以最终main方法的时间复杂度就是O(n^2)。
    
* 最坏情况
  - 案列
  ```python
    public int search(int num){
        int[] arr = {11,10,8,9,7,22,23,0}
        for (int i = 0; i < arr.length; i++){
            if(num == arr[i]){
                return i;
            }
        }
        return -1;
    } 
  ```
    **最好情况**：
    &emsp;&emsp;查找的第一个数字就是期望的数字，那么算法复杂度为O(1)。
    **最坏情况**：
    &emsp;&emsp;查找的最后一个数字，才是期望的数字，那么算法的时间复杂度为O(n)。
    **平均情况**：
    &emsp;&emsp;任何数字查找的平均成本是O(n/2)。
    最坏情况是一种保证，所以除非特别指定，我们提到的运行时间都指的是最坏情况下的运行时间。
