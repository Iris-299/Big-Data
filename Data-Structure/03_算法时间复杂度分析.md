#算法分析

## 算法的时间复杂度分析
* **事后分析估算方法**：计时器计时
  > 缺陷：必须依据算法实现编制好的测试程序，要花费大量时间和精力，如果不行要全部重来，并且不同的测试环境（硬件）的差别导致测试的结果差异很大。

```python
  long start = System.currentTimeMills();
  ...
  long end = System.currentTimeMills();
  System.out.println(end-start);
```
 
* **事前分析估算方法**：<br> 

  程序在计算机上运行所消耗的时间取决于下列因素：
    1. **算法采用的策略和方案**；
    2. 编译产生的代码质量；
    3. **问题的输入规模（输入量的多少）**；
    4. 机器执行指令的速度；
    
  <br> 例：计算1到100的和
```python
  #第一种方法（算法一）
  public static void main(String[] args){
      int sum = 0;//执行1次
      int n = 100;//执行1次
      for (int i = 1; i <= n; i++){//执行了n+1次
          sum += 1；//执行了n次
      }
      System.out.println("sum = " + sum);
  }
```
```python
  #第二种方法（算法二）
  public static void main(String[] args){
      int sum = 0;//执行1次
      int n = 100;//执行1次
      sum = (n+1)*n/2;//执行1次
      System.out.println("sum = " + sum);
  }
```
&emsp;&emsp;当输入规模为n时，把循环体看成整体，忽略结束条件的判断，两个算法的运行时间的差距就是n和1的差距。
  
<br> &emsp;&emsp;要精确研究循环条件执行多少次很麻烦并且真正计算的代码是内循环的循环体，所以在研究算法效率时，我们只考虑核心代码的执行次数，这样可以简化分析。
```python
  #计算100个1+100个2+100个3+……100个100的结果：（算法三）

  public static void main(String[] args){
      int sum = 0;
      int n = 100;
      for (int i = 1; i <= n; i++){
          for (int j = 1; j <= n; j++){
              sum += 1;
          }
      }
      System.out.println("sum = " + sum);
  }
```
&emsp;&emsp;**我们分析一个算法的时间最重要的就是把核心操作的次数和输入规模关联起来。**
### 01 函数渐进增长
> 给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n>N，f(n)总是比g(n)大,那么我们说f(n)的增长渐进快于g(n)。

* **随着输入规模的增大，算法的常数操作可以忽略不计。**
* **随着输入规模的增大，与最高次项项乘的常数可以忽略。**
* **最高次项的指数大的，随着n的增长，结果也会变得增长特别快。**
* **算法函数中n最高次幂越小，算法效率越高。**

### 02 算法时间复杂度
### 大O记法
> 在进行算法分析时，语句总的执行次数T(n)是关于规模n的函数。算法的时间复杂度，就是算法的时间量度，记作：**T(n)=O(f(n))**。用大写O()来体现算法时间复杂度的记法，我们称之为大O记法。

* 推导大O阶的表示法的规则：
  1. 用常数1取代运行时间中的所有假发常数；
  2. 在修改后的运行次数中，只保留高阶项；
  3. 如果最高阶项存在，且常数因子不为1，则去除这个项项乘的常数；

  所以，上述三个算法的大O记法分别为：
    <br> &emsp;&emsp;算法一：O(n)
    <br> &emsp;&emsp;算法二：O(1)
    <br> &emsp;&emsp;算法三：O(n^2)
    
* 常见的大O阶
  - 线性阶
    <br> 一般含有非嵌套循环涉及线性阶，线性阶就是随着输入规模的扩大，对应计算次数呈直线增长，例如：算法一。
  
  - 平方阶
    <br> 一般嵌套循环属于这种时间复杂度。如算法三。
    
  - 立方阶
    <br> 一般三层嵌套属于这种时间复杂度。
    
  - 对数阶
    <br> 由于每次i*2之后，就距离n更近一步，假设有x个2相乘后大于n，则会退出循环。于是2^x=n，得到x=log2(n)，因此时间复杂度为O(logn);
    <br> 对于对数阶，由于随着输入规模n的增大，不管底数多少，趋势相同，因此可忽略底数。
  ```python
    int i = 1, n= 100;
    while(i < n){
      i = i*2;
    }
  ```

  - 常数阶
    <br> 一般不涉及循环操作的都是常数阶，因为它不会随着n的增长而增长增加操作次数。如算法二。
    
  **总结**
  |描述|增长的数量级|说明|举例|
  |:-|:-|:-|:-|
  |常数级别|1|普通语句|将两个数相加|
  |对数级别|logN|二分策略|二分查找|
  |线性级别|N|循环|找出最大元素|
  |线型对数级别|NlogN|分治思想|归并排序|
  |平方级别|N^2|双层循环|检查所有元素对|
  |立方级别|N^3|三层循环|检查所有三元组|
  |指数级别|2^N|穷举查找|检查所有子集|
  
  他们的复杂程度从低到高依次为：
    <br> O(1)<O(logn)<O(n^2)<O(n^3)
  <br> 如果算法的时间复杂度为平方阶、立方阶或者更复杂的，我们认为这种算法是不可取的，需要优化。
  
* 函数调用的时间复杂度分析
  - 案例
  ```python
    public static void main(String[] args){
        int n = 100;
        show(n);
        for (int i = 1; i <= n; i++){
            show(i);
        }
        for (int i = 1; i <= n; i++){
            for (int j = 1; j <= n; j++){
                System.out.println(i);
            }
        }
    }
    
    private static void show(int i){
        for (int i = 1; i <= n; i++){
            System.out.println(i);
        }
    }
  ```
    在show方法中，有一个for循环，所以show方法的时间复杂度为O(n)，在main方法中，show(n)这行代码内部执行次数为n，第一个for循环内调用了show方法，所以其执行次数为n^2，第二个嵌套for循环内只执行了一行代码，所以其执行次数为n^2，那么main方法总执行次数为n+n^2+n^2。由根据大O推导规则，所以最终main方法的时间复杂度就是O(n^2)。
    
* 最坏情况
  - 案列
  ```python
    public int search(int num){
        int[] arr = {11,10,8,9,7,22,23,0}
        for (int i = 0; i < arr.length; i++){
            if(num == arr[i]){
                return i;
            }
        }
        return -1;
    } 
  ```
    **最好情况**：
    &emsp;&emsp;查找的第一个数字就是期望的数字，那么算法复杂度为O(1)。
    **最坏情况**：
    &emsp;&emsp;查找的最后一个数字，才是期望的数字，那么算法的时间复杂度为O(n)。
    **平均情况**：
    &emsp;&emsp;任何数字查找的平均成本是O(n/2)。
    最坏情况是一种保证，所以除非特别指定，我们提到的运行时间都指的是最坏情况下的运行时间。

## 算法的空间复杂度分析


### java中常见的内存占用

* 基本数据类型内存占用的情况：
  |数据类型|内存占用字节数|
  |:-:|:-:|
  |byte|1|
  |short|2|
  |int|4|
  |long|8|
  |float|4|
  |double|8|
  |boolean|1|
  |char|2|
  
* 计算机访问内存的方式都是一次一个字节。

* 一个引用（机器地址）需要8个字节表示：

* 创建一个对象，该对象本身也有内存开销，每个对象的自身开销是16个字节，用来保存对象的信息。

* 一般内存的使用，如果不够8个字节，都会被自动填充为8字节。

* java中数组被限定为对象，他们一般会因为记录长度而需要额外的内存，一个原始数据类型的数组一般需要24字节的头信息（16个自己的对象开销，4个字节用于保存长度以及4个填充字节）再加上保存值所需的内存。

### 算法的空间复杂度
> 公式记作：** S(n)=O(f(n))**，其中n为输入规模，f(n)为语句关于n所占空间的函数。

 - 案例：对指定的数组元素进行反转，并返回反转的内容。
 ```python
   #解法一
   public static int[] reverse1(int[] arr){
      int n = arr.length;//申请4个字节
      int temp;//申请4个字节
      for(int start = 0, end = n - 1; start <= end; start++, end--){
          temp = arr[start];
          arr[start] = arr[end];
          arr[end] = temp;
      }
      return arr;
   }
 ```  
 ```python
   #解法二
   public static int[] reverse1(int[] arr){
      int n = arr.length;//申请4个字节
      int[] temp = new int[n];//申请n*4个字节+数组自身头信息开销的24个字节
      for(int i = n - 1; i >= 0; i--){
          temp[n-1-i] = arr[i];
      }
      return temp;
   }
 ```
  忽略判断条件占用的内存，我们得到的内存占用情况如下：
     算法一：不管传入数组大小为多少，始终额外申请8个字节
     算法二：4n+28个字节
  根据大O推导法则，算法一空间复杂度为O(1)，算法二的空间复杂度为O(n)，所以从空间占用的角度讲，算法一要优于算法二。
  
 **由于现在计算机设备内存一般都比较大，所以内存占用一般不是我们算法的瓶颈，普通情况下直接说复杂度，默认为算法的时间复杂度。**
